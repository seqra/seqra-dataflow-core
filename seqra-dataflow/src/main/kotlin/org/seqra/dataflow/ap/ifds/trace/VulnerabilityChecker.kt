package org.seqra.dataflow.ap.ifds.trace

import org.seqra.dataflow.ap.ifds.MethodEntryPoint
import org.seqra.dataflow.ap.ifds.TaintAnalysisUnitRunnerManager
import org.seqra.dataflow.ap.ifds.TaintMarkAccessor
import org.seqra.dataflow.ap.ifds.access.FinalFactAp
import org.seqra.dataflow.ap.ifds.analysis.MethodCallFlowFunction
import org.seqra.dataflow.ap.ifds.taint.TaintSinkTracker.TaintVulnerability
import org.seqra.dataflow.ap.ifds.taint.TaintSinkTracker.TaintVulnerabilityWithEndFactRequirement
import org.seqra.dataflow.ap.ifds.trace.MethodForwardTraceResolver.EdgeReason
import org.seqra.dataflow.ap.ifds.trace.MethodForwardTraceResolver.RelevantFactFilter
import org.seqra.dataflow.ap.ifds.trace.MethodForwardTraceResolver.TraceEdge
import org.seqra.ir.api.common.CommonMethod
import org.seqra.ir.api.common.cfg.CommonInst

class VulnerabilityChecker(
    private val entryPointMethods: Set<CommonMethod>,
    private val manager: TaintAnalysisUnitRunnerManager,
    private val cancellation: ProcessingCancellation,
) {
    enum class VulnerabilityVerificationStatus {
        CONFIRMED, UNCONFIRMED, UNKNOWN
    }

    data class VerifiedVulnerability(
        val vuln: TaintVulnerability,
        val status: VulnerabilityVerificationStatus,
    )

    fun verifyVulnerability(vulnerability: TaintVulnerabilityWithEndFactRequirement): VerifiedVulnerability {
        val requiredFacts = vulnerability.endFactRequirement
        val vuln = vulnerability.vulnerability
        if (requiredFacts.size != 1) {
            return VerifiedVulnerability(vuln, status = VulnerabilityVerificationStatus.UNKNOWN)
        }

        val startFact = requiredFacts.single()
        val startRequest = VulnConfirmationRequest(
            vulnerability.methodEntryPoint, vulnerability.statement,
            fact = startFact, resolveFromMethodStartDown = false
        )

        val unprocessed = mutableListOf(startRequest)
        val visited = hashSetOf<VulnConfirmationRequest>()
        while (unprocessed.isNotEmpty()) {
            if (!cancellation.isActive) {
                return VerifiedVulnerability(vuln, status = VulnerabilityVerificationStatus.UNKNOWN)
            }

            val request = unprocessed.removeLast()
            if (!visited.add(request)) continue

            if (factReachAnalysisEnd(request, unprocessed)) {
                return VerifiedVulnerability(vuln, status = VulnerabilityVerificationStatus.CONFIRMED)
            }
        }

        return VerifiedVulnerability(vuln, status = VulnerabilityVerificationStatus.UNCONFIRMED)
    }

    private data class VulnConfirmationRequest(
        val ep: MethodEntryPoint,
        val statement: CommonInst,
        val fact: FinalFactAp,
        val resolveFromMethodStartDown: Boolean,
    )

    private fun factReachAnalysisEnd(
        request: VulnConfirmationRequest,
        unprocessed: MutableList<VulnConfirmationRequest>,
    ): Boolean {
        val intraProcCheck = factReachAnalysisEndIntraProcCheck(request, unprocessed)
        when (intraProcCheck) {
            is IntraProcCheckResult.AnalysisEndReached -> return true
            is IntraProcCheckResult.FactCleaned -> return false
            is IntraProcCheckResult.CheckCallerContext -> {
                if (request.resolveFromMethodStartDown) return false

                val callers = manager.findMethodCallers(request.ep)

                // we reach entry point
                // todo: maybe simply check ep in entrypoints. Works bad if we start from all methods
                if (callers.isEmpty()) return true

                for (caller in callers) {
                    val callerFacts = manager.withMethodRunner(caller.callerEp) {
                        intraProcCheck.summaries.flatMapTo(hashSetOf()) {
                            resolveCalleeFact(caller.callerEp, caller.statement, it)
                        }
                    }
                    callerFacts.mapTo(unprocessed) {
                        VulnConfirmationRequest(
                            caller.callerEp, caller.statement, it,
                            resolveFromMethodStartDown = false
                        )
                    }
                }

                return false
            }
        }
    }

    sealed interface IntraProcCheckResult {
        data object AnalysisEndReached : IntraProcCheckResult
        data object FactCleaned: IntraProcCheckResult
        data class CheckCallerContext(val summaries: Set<FinalFactAp>) : IntraProcCheckResult
    }

    private fun factReachAnalysisEndIntraProcCheck(
        request: VulnConfirmationRequest,
        unprocessed: MutableList<VulnConfirmationRequest>,
    ): IntraProcCheckResult {
        val requiredFacts = request.fact.getAllAccessors().filterIsInstanceTo<TaintMarkAccessor, _>(hashSetOf())

        val filter = object : RelevantFactFilter {
            override fun factIsRelevant(statement: CommonInst, fact: FinalFactAp): Boolean =
                fact.getAllAccessors().any { it in requiredFacts }
        }

        val trace = manager.withMethodRunner(request.ep) {
            resolveIntraProceduralForwardFullTrace(
                request.ep, request.statement, request.fact,
                includeStatement = request.resolveFromMethodStartDown,
                filter
            )
        }

        val endFacts = hashSetOf<FinalFactAp>()
        val summaryFacts = hashSetOf<FinalFactAp>()

        val nodes = mutableListOf(trace.initial)
        val visitedNodes = hashSetOf<MethodForwardTraceResolver.TraceNode>()
        while (nodes.isNotEmpty()) {
            val node = nodes.removeLast()
            if (!visitedNodes.add(node)) continue

            val nodeSuccessors = trace.successors[node].orEmpty()
            if (nodeSuccessors.isEmpty()) {
                error("Non-final trace node without successors")
            }

            for (nodeSuccessor in nodeSuccessors) {
                when (nodeSuccessor) {
                    is TraceEdge.Transition -> {
                        val reason = nodeSuccessor.reason
                        if (!trace.successors[nodeSuccessor.successor].isNullOrEmpty()) {
                            nodes.add(nodeSuccessor.successor)
                            continue
                        }

                        TODO("Trace ends with reason $reason")
                    }

                    is TraceEdge.Drop -> {
                        val reason = nodeSuccessor.reason
                        if (reason !is EdgeReason.Call) {
                            TODO("Fact is dropped with non-call reason $reason")
                        }

                        when (val ci = reason.info) {
                            is EdgeReason.CallInfo.CallTraceInfo -> when (ci.info) {
                                is MethodCallFlowFunction.TraceInfo.Rule -> {
                                    // we have a cleaner here
                                    continue
                                }

                                is MethodCallFlowFunction.TraceInfo.Flow -> {
                                    TODO("Unexpected fact drop")
                                }
                            }

                            is EdgeReason.CallInfo.CallSummaryInfo -> {
                                val calleeStartFact = node.fact.rebase(ci.startFactBase)
                                unprocessed += VulnConfirmationRequest(
                                    ci.callEp, ci.callEp.statement, calleeStartFact,
                                    resolveFromMethodStartDown = true
                                )
                            }
                        }
                    }

                    is TraceEdge.MethodEnd -> {
                        endFacts.add(node.fact)
                    }

                    is TraceEdge.MethodSummary -> {
                        summaryFacts.add(node.fact)
                    }
                }
            }
        }

        // fact leave method scope, check caller context
        if (summaryFacts.isNotEmpty()) return IntraProcCheckResult.CheckCallerContext(summaryFacts)

        // we have a non-summary fact which reaches method end
        // for now we assume that this fact can reach analysis end
        // todo: do something with renaming like %0 = %1
        if (endFacts.isNotEmpty()) return IntraProcCheckResult.AnalysisEndReached

        return IntraProcCheckResult.FactCleaned
    }
}
